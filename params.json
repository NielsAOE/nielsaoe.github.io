{
  "name": "Jonida Game Engine",
  "tagline": "",
  "body": "**Exercise** subfolder contains our exercises\r\n\r\n**Game Engine** subfolder contains the game engine\r\n\r\n# Game Engine\r\n\r\n![Game Engine Class diagram](ClassDiagram.svg \"Game Engine Class Diagram\")\r\n\r\n# Engine Classes\r\n\r\nThe structure of this game engine is similar to that of Unity.\r\nAs seen on the class diagram (see figure 1), it uses a scene structure, with the game objects themselves being loaded through a .json-file. \r\nThe engine supports a number of components, which can be added to or removed from a specific game object. The engine also supports multiple scriptable components attached to a single game object.\r\n\r\n### GameObject\r\n\r\nA game object is the base class for all entities, which are the things we want to draw and manipulate in our game world. A game object contains a number of components, each containing various information about the game object, for instance transform, various scripts and the physics of the object.\r\n\r\n![GameObject](html/class_game_object__coll__graph.svg \"GameObject\")\r\n### Component\r\n\r\nA component is the base class for everything which is to be attached to a game object. This includes components to determine the rotation and size of a game object, its physics as well as scripts and others.\r\n![Component diagram](html/class_component__inherit__graph.svg \"Component Diagram\")\r\n\r\n### AudioSource\r\n\r\nThe engine uses the irrKlang-library to imitate 3D sounds in the game world. This component contains a single irrKlang-device, to which Audio sounds are added.\r\n\r\n### LightSource\r\n\r\nThe engine can currently create directional- or point-lights. To create a light, it must be given a direction, a colour and a range of the light. The position of the light is dependent on the game object the LightSource-component is attached to. Lights are created using the SimpleRenderEngine, and any limitations this must have (such as number of possible active lights) are applicable to this engine. It is currently possible to change either the colour or range of a specific light, as well as its type during runtime.\r\n\r\n### ParticleSystem\r\n\r\nA simple system to emit particles. The system contains methods to change the colour, size and velocity of the current particles. The colour and size can either be static, differ randomly between two values, change linearly over time from one value to another, or change following a Catmull-Rom spline. The particles can be set to emit in either a random direction 360° around the game object the system is attached to, or in the direction of a given glm::vector3. To set the direction to a vector, however, the method needs to be called after starting the system, as the system uses circular random as standard.\r\n\r\n### Renderer\r\n\r\nA renderer is a component and is what draws the game object, making it appear on the screen. It contains the colour of the game object, and has access to transform components for drawing the game object.\r\n\r\n### Rigidbody\r\n\r\nA game object with a rigidbody has physics imposed on it. The engine supports either dynamic, static or kinematic rigidbodies. Rigidbodies can be either boxes or circles. The engine utilizes Box2D to create physics.\r\n\r\n### Scriptable\r\n\r\nTo make the engine more dynamic, we have created a scriptable component. This enables multiple, unique scripts to be written and attached to each game object. An example could be a CharacterController, which allows gameObjects to move accordingly to the script. The scriptable component currently contains an Awake, Start and Update method. Awake() is called when the game object is created, Start() is called when the game object is initialized and Update() is called every frame. Scripts can currently only be written in C++.\r\n\r\n### Transform\r\n\r\nAll GameObjects are created with a Transform Component, and it includes the position, rotation and scale of an object. These values can then be manipulated to change the appearance and position of the game object. \r\n\r\n### PhysicsManager\r\n\r\nThe physics manager contains the physics world in which all Rigidbody fixtures are contained. It is used to step the physics for all fixtures from the Engine loop.\r\nIt also has methods which gets called when two colliders either begin touching each other or just before they leave each other. This in turns checks if any of the colliders have any scripts attached, and if they do, calls their OnCollisionEnter() or OnCollisionExit(), respectively.\r\n\r\n### Scene\r\n\r\nThe scene is the “game world”. All game objects are stored in the scene. Game objects can either be added or removed from a scene, as well as get a specific game object currently contained in the scene. It is also possible to get all the game objects currently stored in a scene.\r\n\r\n### SceneParser\r\n\r\nThe engine utilizes picojson to read game objects from a .json-file, creating and storing them in a scene. Each game object read from a .json-file must contain:\r\n\r\n - A unique ID\r\n - A name\r\n - Name of the mesh type\r\n - Color\r\n - Position\r\n - Rotation\r\n - Scale\r\n - ParentID, 0 if it has no parent\r\n - Bounce value\r\n - Density\r\n - Fixture, which can be set to \"NOFIXTURE\", \"DYNAMIC\", \"STATIC\" or \"KINEMATIC\"\r\n\r\n### Engine\r\n\r\nThe engine class is what ties the actual engine together. It contains the main game loop, where all components and scripts are updated. It also contains the method called when loading a scene, and contains the actual scene, keeping information of all the current game objects in the scene. This class is also responsible for initializing and loading the SimpleRenderEngine as well as dear imgui. The Awake() and Start() methods of scripts are also called from this class. All inputs from the InputManager is handled within this class, and it also controls if the debug window should be shown. The debug windows contains information regarding the applications current usage of RAM and virtual memory, as well as high water marks for these. Furthermore, it is possible to view the unique ID of each game object, as well as all components currently attached to it.\r\n![Engine](html/class_engine__coll__graph.svg \"Engine\")\r\n### Particle\r\n\r\nParticles are used by the particle system. Each particle contains their current position, their velocity and the time of which they were created.\r\n\r\n### Audio\r\n\r\nAudio is a wrapper class, containing the actual clip to be played by the called AudioSource-component. This is so users of our engine won’t have to interact with irrKlang themselves.\r\n\r\n### CameraHandler\r\n\r\nThe camerahandler, while not a component in itself, can be accessed and used to manipulate the camera of the world. All interaction with the camera is done through this class, and it contains methods to change the projection of the camera between orthographic and perspective. Furthermore, the specific area the camera should look at can also be changed. Lastly, it also allows the possibility of following a specific game object.\r\n\r\n### InputManager\r\n\r\nThe engine contains a singleton input manager. The manager uses SDL_events to handle key inputs. This is done by setting a bool to true when a key is pressed and held down, and false as soon as the key is released.\r\n\r\n### LeakDetection\r\n\r\nThe engine currently supports the possibility of keeping track of a number of things, including:\r\n\r\n - Total RAM on the machine\r\n - Current RAM free on the machine\r\n - Current RAM used by the machine\r\n - Current RAM used by the application/game\r\n - Total virtual memory on the machine\r\n - Current virtual memory used by the application/game\r\n \r\nThese statistics are available on both Windows- and macOS-computers.\r\nHowever, as stated during the \"Engine\"-paragraph, the debug window currently only shows the current RAM and virtual memory usage of the application.\r\n\r\n### PlayerPrefManager\r\n\r\nThe player preferences manager is used to save and load values set by the user. It is currently possible to store both integers, doubles, strings and booleans. It is also possible to check if a value is present in the loaded file. The manager uses a given organisation name and application name, given to SDL_GetPrefPath(), to determine the file path of the preferences file. Files are stored as .json-files using picojson.\r\n\r\n### SpriteAtlas\r\n\r\nThis class loads a texture atlas from a .json file utilizing picojson. A map is used to contain all the sprites, with the name of the sprite being the key.\r\n\r\n### Sprite\r\n\r\nThe class containing the actual sprites. This class slices the texture atlas, based on given parameters, and saves the sprite in the map of the spriteatlas class.\r\n\r\n### Utility\r\n\r\nThe utility class is currently used by the SpriteAtlas class to load .json-files as strings using picojson.\r\n\r\n# Demonstrations\r\n\r\nTo showcase the engine, multiple demonstration-programs have been made. There are a total of three demonstrations, displaying:\r\n\r\n - Physics\r\n - Particles\r\n - 3D Audio\r\n \r\nFurthermore, a platformer game has been made to show multiple features of the engine in one application.\r\n\r\n# Performance\r\n\r\nAs the engine utilizes SimpleRenderEngine, the engine itself is limited in performance to the same performance as SimpleRenderEngine when it comes to rendering a certain amount of game objects.\r\n\r\nWe have found that on a computer with X specifications, the number of frames per seconds starts dropping when there are X game objects in the scene.\r\n\r\n# Discussion\r\n\r\nThe game engine is currently working, as it allows developers to create games, albeit somewhat simple.\r\n\r\nTo improve the engine, a number of features could be implemented. This would also allow for the creation of more complex games. \r\nSome of the features this group would like to see implemented include:\r\n\r\n**A method for unloading/destroying scenes**\r\n\r\nAs it is now, the developer will manually have to delete every game object contained in a scene before loading a new one. Otherwise, the new game objects might overwrite the old ones, and the game objects not overwritten from the old scene can be found in the new. A method specifically to destroy a scene could be created, or the logic could be implemented in the current method for loading scenes, automatically resetting the scene before adding game objects.\r\n\r\n**Expand the possible file formats which can be loaded**\r\n\r\nCurrently only .json-files can be loaded, and meshes can only be either cubes spheres or planes. A possible file format to load could be .obj.\r\n\r\n**Not drawing objects outside the cameras vision**\r\n\r\nTo optimize performance, objects outside the view of the camera could be omitted from being drawn. This ensures fewer objects will be drawn in most cases.\r\n\r\n**Expand possible scripting languages**\r\n\r\nThe engine currently support scripts written in C++. However, to give a greater ease of use and appeal, it would be ideal to expand this to include languages such as JavaScript, C# or Lua.\r\n\r\n**3D Physics**\r\n\r\nWhile the engine itself can be used to make games in 3D, the current physics system utilized is only applicable to 2D. As such, 3D games created using our engine cannot contain physics.\r\n\r\n**Easier to animate sprites**\r\n\r\nAs it is right now, the only way to animate sprites is through a script. This means the developer will have to get every single sprite, wait the appropriate time and draw the new sprite through a script attached to the corresponding game object.\r\n\r\n**Shadows**\r\n\r\nMore complex graphics features, such as shaders and shadows, would be a nice addition to the engine, as this could give more realism to games.\r\n\r\n**Networking**\r\n\r\nIt would also be ideal to implement some sort of networking, making the engine capable of creating online games.\r\n\r\n**User Interface**\r\n\r\nCurrently, the engine can only show a hardcoded user interface when run in debug mode. Creating the possibility of adding UI elements to a game would be greatly beneficial, to create elements such as a start screen or pause screen.\r\n \r\n**Performance**\r\n\r\nAs mentioned, after spawning X number of game objects in the world, the framerate starts dropping. While this could possibly be due to performance constraints from SimpleRenderEngine, there might still be ways to improve the performance of our engine. As stated earlier, objects outside the view of the camera can be omitted from being drawn. Further more, some game objects could be destroyed after reaching a certain number of objects in the scene. But by using this method, means to prevent important game objects from being destroyed will then have to be taken. \r\n\r\nLastly, performance of the engine can always be optimized. But given the time constraints and limited scope of this project, the group believes the engine has an acceptable performance as is.\r\n\r\n# Who did what?\r\n\r\n**Daniel**:\r\n\r\n - PlayerPrefs\r\n - AudioSource\r\n - AudioDemo\r\n - InputManager\r\n - Particle Demo\r\n\r\n\r\n**Johan**:\r\n\r\n - PhysicsDemo\r\n - CameraHandler\r\n - SpriteAtlas\r\n - Sprite\r\n - Game\r\n\r\n\r\n**Niels**:\r\n\r\n - Audio\r\n - AudioSource\r\n - InputManager\r\n - LightSource\r\n - Documentation\r\n - PhysicsManager - OnCollionEnter/OnCollisionExit\r\n - Game\r\n\r\n\r\n*Hvem lavede PhysManager og RigidBody?*\r\n\r\n**Daniel**, **Johan** & **Niels**:\r\n\r\n - Component\r\n - Engine\r\n - GameObject\r\n - LeakDetection\r\n - Particle\r\n - ParticleSystem\r\n - Renderer\r\n - RigidBody\r\n - Scene\r\n - Scriptable\r\n - Transform\r\n - etc.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}